"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[1330],{3905:(e,t,n)=>{n.d(t,{Zo:()=>l,kt:()=>h});var a=n(67294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},i=Object.keys(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var c=a.createContext({}),p=function(e){var t=a.useContext(c),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},l=function(e){var t=p(e.components);return a.createElement(c.Provider,{value:t},e.children)},d={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},u=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,i=e.originalType,c=e.parentName,l=s(e,["components","mdxType","originalType","parentName"]),u=p(n),h=r,m=u["".concat(c,".").concat(h)]||u[h]||d[h]||i;return n?a.createElement(m,o(o({ref:t},l),{},{components:n})):a.createElement(m,o({ref:t},l))}));function h(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var i=n.length,o=new Array(i);o[0]=u;var s={};for(var c in t)hasOwnProperty.call(t,c)&&(s[c]=t[c]);s.originalType=e,s.mdxType="string"==typeof e?e:r,o[1]=s;for(var p=2;p<i;p++)o[p]=n[p];return a.createElement.apply(null,o)}return a.createElement.apply(null,n)}u.displayName="MDXCreateElement"},43258:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>o,default:()=>d,frontMatter:()=>i,metadata:()=>s,toc:()=>p});var a=n(87462),r=(n(67294),n(3905));const i={sidebar_position:1,title:"Main Concepts"},o=void 0,s={unversionedId:"integrations/spark/main_concept",id:"integrations/spark/main_concept",title:"Main Concepts",description:'Spark jobs typically run on clusters of machines. A single machine hosts the "driver" application,',source:"@site/docs/integrations/spark/main_concept.md",sourceDirName:"integrations/spark",slug:"/integrations/spark/main_concept",permalink:"/docs/integrations/spark/main_concept",draft:!1,editUrl:"https://github.com/OpenLineage/docs/tree/main/docs/integrations/spark/main_concept.md",tags:[],version:"current",sidebarPosition:1,frontMatter:{sidebar_position:1,title:"Main Concepts"},sidebar:"tutorialSidebar",previous:{title:"Apache Spark",permalink:"/docs/integrations/spark/"},next:{title:"Installation",permalink:"/docs/integrations/spark/installation"}},c={},p=[{value:"Collecting Lineage in Spark",id:"collecting-lineage-in-spark",level:2}],l={toc:p};function d(e){let{components:t,...i}=e;return(0,r.kt)("wrapper",(0,a.Z)({},l,i,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Spark jobs typically run on clusters of machines. A single machine hosts the \"driver\" application,\nwhich constructs a graph of jobs - e.g., reading data from a source, filtering, transforming, and\njoining records, and writing results to some sink- and manages execution of those jobs. Spark's\nfundamental abstraction is the Resilient Distributed Dataset (RDD), which encapsulates distributed\nreads and modifications of records. While RDDs can be used directly, it is far more common to work\nwith Spark Datasets or Dataframes, which is an API that adds explicit schemas for better performance\nand the ability to interact with datasets using SQL. The Dataframe's declarative API enables Spark\nto optimize jobs by analyzing and manipulating an abstract query plan prior to execution."),(0,r.kt)("h2",{id:"collecting-lineage-in-spark"},"Collecting Lineage in Spark"),(0,r.kt)("p",null,"Collecting lineage requires hooking into Spark's ",(0,r.kt)("inlineCode",{parentName:"p"},"ListenerBus")," in the driver application and\ncollecting and analyzing execution events as they happen. Both raw RDD and Dataframe jobs post events\nto the listener bus during execution. These events expose the structure of the job, including the\noptimized query plan, allowing the Spark integration to analyze the job for datasets consumed and\nproduced, including attributes about the storage, such as location in GCS or S3, table names in a\nrelational database or warehouse, such as Redshift or Bigquery, and schemas. In addition to dataset\nand job lineage, Spark SQL jobs also report logical plans, which can be compared across job runs to\ntrack important changes in query plans, which may affect the correctness or speed of a job."),(0,r.kt)("p",null,"A single Spark application may execute multiple jobs. The Spark OpenLineage integration maps one\nSpark job to a single OpenLineage Job. The application will be assigned a Run id at startup and each\njob that executes will report the application's Run id as its parent job run. Thus, an application\nthat reads one or more source datasets, writes an intermediate dataset, then transforms that\nintermediate dataset and writes a final output dataset will report three jobs- the parent application\njob, the initial job that reads the sources and creates the intermediate dataset, and the final job\nthat consumes the intermediate dataset and produces the final output. As an image:\n",(0,r.kt)("img",{alt:"image",src:n(83189).Z,width:"1289",height:"204"})))}d.isMDXComponent=!0},83189:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/images/spark-job-creation.dot-d3fd1094587dcacc0c8a1566dac60ed5.png"}}]);