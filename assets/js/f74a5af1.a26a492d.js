"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[2738],{3905:(e,t,r)=>{r.d(t,{Zo:()=>c,kt:()=>m});var a=r(7294);function n(e,t,r){return t in e?Object.defineProperty(e,t,{value:r,enumerable:!0,configurable:!0,writable:!0}):e[t]=r,e}function o(e,t){var r=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),r.push.apply(r,a)}return r}function i(e){for(var t=1;t<arguments.length;t++){var r=null!=arguments[t]?arguments[t]:{};t%2?o(Object(r),!0).forEach((function(t){n(e,t,r[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(r)):o(Object(r)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(r,t))}))}return e}function s(e,t){if(null==e)return{};var r,a,n=function(e,t){if(null==e)return{};var r,a,n={},o=Object.keys(e);for(a=0;a<o.length;a++)r=o[a],t.indexOf(r)>=0||(n[r]=e[r]);return n}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)r=o[a],t.indexOf(r)>=0||Object.prototype.propertyIsEnumerable.call(e,r)&&(n[r]=e[r])}return n}var l=a.createContext({}),p=function(e){var t=a.useContext(l),r=t;return e&&(r="function"==typeof e?e(t):i(i({},t),e)),r},c=function(e){var t=p(e.components);return a.createElement(l.Provider,{value:t},e.children)},d={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},u=a.forwardRef((function(e,t){var r=e.components,n=e.mdxType,o=e.originalType,l=e.parentName,c=s(e,["components","mdxType","originalType","parentName"]),u=p(r),m=n,f=u["".concat(l,".").concat(m)]||u[m]||d[m]||o;return r?a.createElement(f,i(i({ref:t},c),{},{components:r})):a.createElement(f,i({ref:t},c))}));function m(e,t){var r=arguments,n=t&&t.mdxType;if("string"==typeof e||n){var o=r.length,i=new Array(o);i[0]=u;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s.mdxType="string"==typeof e?e:n,i[1]=s;for(var p=2;p<o;p++)i[p]=r[p];return a.createElement.apply(null,i)}return a.createElement.apply(null,r)}u.displayName="MDXCreateElement"},3707:(e,t,r)=>{r.r(t),r.d(t,{assets:()=>l,contentTitle:()=>i,default:()=>d,frontMatter:()=>o,metadata:()=>s,toc:()=>p});var a=r(7462),n=(r(7294),r(3905));const o={sidebar_position:1},i="Custom extractors",s={unversionedId:"integrations/airflow/extractors/custom-extractors",id:"integrations/airflow/extractors/custom-extractors",title:"Custom extractors",description:"This integration works by detecting which Airflow operators your DAG is using, and extracting lineage data from them using corresponding extractors.",source:"@site/docs/integrations/airflow/extractors/custom-extractors.md",sourceDirName:"integrations/airflow/extractors",slug:"/integrations/airflow/extractors/custom-extractors",permalink:"/docs/integrations/airflow/extractors/custom-extractors",draft:!1,editUrl:"https://github.com/OpenLineage/docs/tree/main/docs/integrations/airflow/extractors/custom-extractors.md",tags:[],version:"current",sidebarPosition:1,frontMatter:{sidebar_position:1},sidebar:"tutorialSidebar",previous:{title:"Using OpenLineage with older versions of Airflow",permalink:"/docs/integrations/airflow/older"},next:{title:"Testing custom extractors",permalink:"/docs/integrations/airflow/extractors/extractor-testing"}},l={},p=[{value:"Interface",id:"interface",level:2},{value:"Registering custom extractor",id:"registering-custom-extractor",level:2},{value:"Adding extractor to OpenLineage Airflow integration package",id:"adding-extractor-to-openlineage-airflow-integration-package",level:2},{value:"Debugging issues",id:"debugging-issues",level:2}],c={toc:p};function d(e){let{components:t,...r}=e;return(0,n.kt)("wrapper",(0,a.Z)({},c,r,{components:t,mdxType:"MDXLayout"}),(0,n.kt)("h1",{id:"custom-extractors"},"Custom extractors"),(0,n.kt)("p",null,"This integration works by detecting which Airflow operators your DAG is using, and extracting lineage data from them using corresponding extractors."),(0,n.kt)("p",null,"However, not all operators are covered. In particular, third party providers may not be. To handle this situation, OpenLineage allows you to provide custom extractors for any operators where there is not one built-in."),(0,n.kt)("p",null,"If you want to extract lineage from your own Operators, you may prefer directly implementing ",(0,n.kt)("a",{parentName:"p",href:"/docs/integrations/airflow/default-extractors"},"lineage support as described here"),"."),(0,n.kt)("h2",{id:"interface"},"Interface"),(0,n.kt)("p",null,"Custom extractors have to derive from ",(0,n.kt)("inlineCode",{parentName:"p"},"BaseExtractor"),"."),(0,n.kt)("p",null,"Extractors have three methods to implement: ",(0,n.kt)("inlineCode",{parentName:"p"},"extract"),", ",(0,n.kt)("inlineCode",{parentName:"p"},"extract_on_complete")," and ",(0,n.kt)("inlineCode",{parentName:"p"},"get_operator_classnames"),".\nThe last one is a classmethod that is used to provide list of operators that your extractor can get lineage from."),(0,n.kt)("p",null,"For example:"),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-python"},"@classmethod\ndef get_operator_classnames(cls) -> List[str]:\n  return ['PostgresOperator']\n")),(0,n.kt)("p",null,"If the name of the operator matches one of the names on the list, the extractor will be instantiated - with operator\nprovided in the extractor's ",(0,n.kt)("inlineCode",{parentName:"p"},"self.operator")," property - and both ",(0,n.kt)("inlineCode",{parentName:"p"},"extract")," and ",(0,n.kt)("inlineCode",{parentName:"p"},"extract_on_complete")," methods will be called.\nThey are used to provide actual information data. The difference is that ",(0,n.kt)("inlineCode",{parentName:"p"},"extract")," is called before operator's ",(0,n.kt)("inlineCode",{parentName:"p"},"execute"),"\nmethod, while ",(0,n.kt)("inlineCode",{parentName:"p"},"extract_on_complete")," is called after. This can be used to extract any additional information that the operator\nsets on it's own properties. Good example is ",(0,n.kt)("inlineCode",{parentName:"p"},"SnowflakeOperator")," that sets ",(0,n.kt)("inlineCode",{parentName:"p"},"query_ids")," after execution."),(0,n.kt)("p",null,"Both methods return ",(0,n.kt)("inlineCode",{parentName:"p"},"TaskMetadata")," structure:"),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-python"},"@attr.s\nclass TaskMetadata:\n    name: str = attr.ib()  # deprecated\n    inputs: List[Dataset] = attr.ib(factory=list)\n    outputs: List[Dataset] = attr.ib(factory=list)\n    run_facets: Dict[str, BaseFacet] = attr.ib(factory=dict)\n    job_facets: Dict[str, BaseFacet] = attr.ib(factory=dict)\n")),(0,n.kt)("p",null,"Inputs and outputs are lists of plain ",(0,n.kt)("a",{parentName:"p",href:"/docs/client/python"},"OpenLineage datasets")," "),(0,n.kt)("p",null,(0,n.kt)("inlineCode",{parentName:"p"},"run_facets")," and ",(0,n.kt)("inlineCode",{parentName:"p"},"job_facets")," are dictionaries of optional ",(0,n.kt)("a",{parentName:"p",href:"/docs/client/python"},"JobFacets")," and ",(0,n.kt)("a",{parentName:"p",href:"/docs/client/python"},"RunFacets")," that would be attached to the job - for example,\nyou might want to attach ",(0,n.kt)("inlineCode",{parentName:"p"},"SqlJobFacet")," if your operator is executing SQL."),(0,n.kt)("p",null,"To learn more about facets in OpenLineage, please visit this ",(0,n.kt)("a",{parentName:"p",href:"../../../spec/facets"},"section"),"."),(0,n.kt)("h2",{id:"registering-custom-extractor"},"Registering custom extractor"),(0,n.kt)("p",null,"OpenLineage integration does not know that you've provided an extractor unless you'll register it."),(0,n.kt)("p",null,"The way to do that is to add them to ",(0,n.kt)("inlineCode",{parentName:"p"},"OPENLINEAGE_EXTRACTORS")," environment variable."),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre"},"OPENLINEAGE_EXTRACTORS=full.path.to.ExtractorClass\n")),(0,n.kt)("p",null,"If you have multiple custom extractors, separate the paths with comma ",(0,n.kt)("inlineCode",{parentName:"p"},"(;)")," "),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre"},"OPENLINEAGE_EXTRACTORS=full.path.to.ExtractorClass;full.path.to.AnotherExtractorClass\n")),(0,n.kt)("p",null,"Optionally, you can separate them with whitespace. It's useful if you're providing them as part of some YAML file."),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre"},"OPENLINEAGE_EXTRACTORS: >-\n  full.path.to.FirstExtractor;\n  full.path.to.SecondExtractor\n")),(0,n.kt)("p",null,"Remember to make sure that the path is importable for scheduler and worker."),(0,n.kt)("h2",{id:"adding-extractor-to-openlineage-airflow-integration-package"},"Adding extractor to OpenLineage Airflow integration package"),(0,n.kt)("p",null,"All Openlineage extractors are defined in ",(0,n.kt)("a",{parentName:"p",href:"https://github.com/OpenLineage/OpenLineage/blob/main/integration/airflow/openlineage/airflow/extractors"},"this path"),".\nIn order to add new extractor you should put your code in this directory. Additionally, you need to add the class to ",(0,n.kt)("inlineCode",{parentName:"p"},"_extractors")," list in ",(0,n.kt)("a",{parentName:"p",href:"https://github.com/OpenLineage/OpenLineage/blob/main/integration/airflow/openlineage/airflow/extractors/extractors.py"},"extractors.py"),", e.g.:"),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-python"},"_extractors = list(\n    filter(\n        lambda t: t is not None,\n        [\n            try_import_from_string(\n                'openlineage.airflow.extractors.postgres_extractor.PostgresExtractor'\n            ),\n            ... # other extractors are listed here\n+           try_import_from_string(\n+               'openlineage.airflow.extractors.new_extractor.ExtractorClass'\n+           ),\n        ]\n    )\n)\n")),(0,n.kt)("h2",{id:"debugging-issues"},"Debugging issues"),(0,n.kt)("p",null,"There are two common problems associated with custom extractors.\nFirst, is wrong path provided to ",(0,n.kt)("inlineCode",{parentName:"p"},"OPENLINEAGE_EXTRACTORS"),".\nThe path needs to be exactly the same as one you'd use from your code. If the path is wrong or non-importable from worker,\nplugin will fail to load the extractors and proper OpenLineage events for that operator won't be emitted."),(0,n.kt)("p",null,"Second one, and maybe more insidious, are imports from Airflow. Due to the fact that OpenLineage code gets instantiated when\nAirflow worker itself starts, any import from Airflow can be unnoticeably cyclical. This causes OpenLineage extraction to fail."),(0,n.kt)("p",null,"To avoid this issue, import from Airflow only locally - in ",(0,n.kt)("inlineCode",{parentName:"p"},"extract")," or ",(0,n.kt)("inlineCode",{parentName:"p"},"extract_on_complete")," methods. If you need imports for\ntype checking, guard them behind ",(0,n.kt)("inlineCode",{parentName:"p"},"typing.TYPE_CHECKING"),"."),(0,n.kt)("p",null,"You can also check ",(0,n.kt)("a",{parentName:"p",href:"../../../development/developing/"},"Development section")," to learn more about how to setup development environment and create tests."))}d.isMDXComponent=!0}}]);